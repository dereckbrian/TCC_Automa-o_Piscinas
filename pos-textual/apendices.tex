% ----------------------------------------------------------
% Apêndices
% ----------------------------------------------------------
\begin{apendicesenv}

\partapendices

% ==========================================================
% APÊNDICE A - HARDWARE
% ==========================================================
\chapter{Detalhamento dos Componentes de Hardware}
\label{apendice:hardware}

Neste apêndice são apresentados os componentes físicos utilizados na montagem do protótipo, conforme referenciado no Capítulo de Desenvolvimento.

\section{Sensores}

\begin{figure}[H]
    \centering
    \caption{Sensor de Temperatura MF58 (NTC 10K)}
    \label{fig:sensortemp}
    \includegraphics[width=0.70\textwidth]{imagens/sensorTemperatura.png}
    \caption*{Fonte: \cite{siteComprei}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Sensor de Nível LC26M-40}
    \label{fig:sensorlevel}
    \includegraphics[width=0.60\textwidth]{imagens/sensorNive.png}
    \caption*{Fonte: \cite{siteComprei2}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Sensor de pH}
    \label{fig:sensorph}
    \includegraphics[width=0.60\textwidth]{imagens/sensorpH.png}
    \caption*{Fonte: \cite{siteCompreiPh}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Sensor de Turbidez ST100}
    \label{fig:sensorturbidez}
    \includegraphics[width=0.60\textwidth]{imagens/sensorTurbidez.png}
    \caption*{Fonte: \cite{siteCompreiTurbidez}.}
\end{figure}

\section{Atuadores e Controladores}

\begin{figure}[H]
    \centering
    \caption{Bomba Submersa JT100}
    \label{fig:bombasub}
    \includegraphics[width=0.60\textwidth]{imagens/bombaSubmersa.png}
    \caption*{Fonte: \cite{siteComprei}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Placa Arduino Uno R3 (Controlador Físico)}
    \label{fig:arduino}
    \includegraphics[width=0.60\textwidth]{imagens/arduino.png}
    \caption*{Fonte: \cite{siteComprei4}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Raspberry Pi 3 Model B (Gateway)}
    \label{fig:raspberry}
    \includegraphics[width=0.80\textwidth]{imagens/raspBerryQeuUso.png}
    \caption*{Fonte: \cite{siteComprei3}.}
\end{figure}

% ==========================================================
% APÊNDICE B - SOFTWARE
% ==========================================================
\chapter{Códigos Fonte do Sistema}
\label{apendice:codigos}

A seguir, apresentamos os trechos essenciais dos scripts desenvolvidos para o funcionamento do sistema de automação, demonstrando a integração entre as camadas de Firmware, Gateway e Aplicação.

% --- ARDUINO ---
\section{Firmware do Microcontrolador (Arduino)}
\label{cod:arduino}

O código abaixo é responsável pela leitura dos sensores em tempo real e controle imediato do relé da bomba, garantindo segurança operacional mesmo sem conexão de rede.

\small
\begin{verbatim}
#define PINO_PH A0        
#define PINO_TEMP A1       
#define PINO_RELE 6       
#define PINO_BOIA 7       

// Configuracao NTC 10k
#define R_FIXO 10000.0     
#define RT0 10000.0        
#define BETA 3950.0        

float calibracao_slope = 0.18; 
int estadoBomba = 0;
bool forcarLigado = false; 

// Variavel para controlar o tempo do envio
unsigned long ultimoEnvio = 0;

void setup() {
  Serial.begin(9600);
  
  pinMode(PINO_PH, INPUT);
  pinMode(PINO_BOIA, INPUT_PULLUP);
  pinMode(PINO_RELE, OUTPUT);        
  
  digitalWrite(PINO_RELE, LOW);    
  Serial.println("INICIO: MODO TURBO ATIVADO");
}

void loop() {
  // 1. LEITURA E CONTROLE IMEDIATO
  if (Serial.available() > 0) {
    char comando = Serial.read();
    if (comando == 'L') forcarLigado = true;
    if (comando == 'D') forcarLigado = false;
  }

  int leituraBoia = digitalRead(PINO_BOIA);
  
  // Logica de Seguranca Local
  bool deveLigar = (leituraBoia == HIGH) || (forcarLigado == true);

  if (deveLigar) { 
      digitalWrite(PINO_RELE, HIGH); 
      estadoBomba = 1; 
  } 
  else { 
      digitalWrite(PINO_RELE, LOW);
      estadoBomba = 0; 
  }

  // 2. ENVIAR DADOS (A CADA 2 SEGUNDOS)
  if (millis() - ultimoEnvio > 2000) {
      ultimoEnvio = millis(); 
      
      // Calculo Temperatura
      float tempCelsius = 0;
      int leituraTemp = analogRead(PINO_TEMP);
      float voltagemTemp = leituraTemp * (5.0 / 1023.0);
      if (voltagemTemp > 0.1 && voltagemTemp < 4.9) {
          float r_termistor = R_FIXO * (5.0 - voltagemTemp) / voltagemTemp;
          float tempKelvin = 1.0 / (1.0 / (273.15 + 25.0) + log(r_termistor / RT0) / BETA);
          tempCelsius = tempKelvin - 273.15;
      }

      // Calculo pH
      long somaLeituras = 0;
      for(int i = 0; i < 10; i++) {
        somaLeituras += analogRead(PINO_PH);
        delay(10); 
      }
      float mediaPH = somaLeituras / 10.0;
      float voltagemPH = mediaPH * (5.0 / 1023.0);
      float valorPH = 7.00 + ((2.50 - voltagemPH) / calibracao_slope);

      // Serializacao JSON
      Serial.print("{\"t\":");
      Serial.print(tempCelsius);
      Serial.print(",\"n\":");
      Serial.print(leituraBoia == HIGH ? 0 : 1); 
      Serial.print(",\"p\":");
      Serial.print(valorPH);
      Serial.print(",\"b\":");
      Serial.print(estadoBomba);
      Serial.println("}");
  }
}
\end{verbatim}
\normalsize

% --- PYTHON ---
\section{Script do Gateway (Python)}
\label{cod:python}

Este script roda no Raspberry Pi, atuando como ponte entre a porta Serial (USB) e a API REST.

\small
\begin{verbatim}
import serial
import json
import requests
import time
import sys

# --- CONFIGURACOES ---
PORTA_ARDUINO = '/dev/ttyUSB0' 
VELOCIDADE = 9600
IP_PC = "10.0.0.241" 
URL_BACKEND = f"http://{IP_PC}:8080/api/sensor/receber"

def conectar_arduino():
    while True:
        try:
            print(f" Tentando conectar ao Arduino em {PORTA_ARDUINO}...")
            ser = serial.Serial(PORTA_ARDUINO, VELOCIDADE, timeout=1)
            time.sleep(2) 
            print(" Conectado com sucesso!")
            return ser
        except serial.SerialException:
            print(" Arduino nao encontrado. Tentando de novo em 3s...")
            time.sleep(3)

# --- LOOP PRINCIPAL ---
arduino = conectar_arduino()

while True:
    try:
        if arduino.in_waiting > 0:
            try:
                linha = arduino.readline().decode('utf-8', errors='ignore').strip()
                
                if not linha: continue

                print(f" Enviando: {linha}")
                dados = json.loads(linha)
                
                # Envia e aguarda resposta do comando (Ligar/Desligar)
                resposta = requests.post(URL_BACKEND, json=dados, timeout=2)
                
                if resposta.status_code == 200:
                    try:
                        comando_java = resposta.json()
                        if comando_java.get("ligarBomba") == True:
                            arduino.write(b'L') 
                        elif comando_java.get("ligarBomba") == False:
                            arduino.write(b'D') 
                    except json.JSONDecodeError:
                        pass 
                
            except json.JSONDecodeError:
                pass
            except requests.exceptions.RequestException as e:
                print(f" Erro de conexao com o Java: {e}")

    except (OSError, serial.SerialException):
        if 'arduino' in locals() and arduino.is_open:
            arduino.close()
        arduino = conectar_arduino()
        
    except KeyboardInterrupt:
        if 'arduino' in locals() and arduino.is_open:
            arduino.close()
        break
\end{verbatim}
\normalsize

% --- JAVA ---
\section{Controller do Back-end (Java/Spring Boot)}
\label{cod:java}

Controlador REST responsável por receber os dados do Gateway e persisti-los no banco PostgreSQL.

\small
\begin{verbatim}
package com.ifg.residIFG.controllers;

import com.ifg.residIFG.domain.piscinas.LeituraSensor;
import com.ifg.residIFG.repository.LeituraSensorRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/sensor")
@CrossOrigin(origins = "*")
public class SensorController {

    @Autowired
    private LeituraSensorRepository repository;

    @PostMapping("/receber")
    public void receberDados(@RequestBody Map<String, Object> dados) {
        Double temp = Double.valueOf(dados.get("t").toString());
        
        Integer nivelRaw = Integer.valueOf(dados.get("n").toString());
        Boolean nivel = (nivelRaw == 1);

        Double ph = Double.valueOf(dados.get("p").toString());

        Integer bombaRaw = Integer.valueOf(dados.get("b").toString());
        Boolean bombaAtiva = (bombaRaw == 1);

        LeituraSensor leitura = new LeituraSensor(temp, nivel, ph, bombaAtiva);

        repository.save(leitura);
        // Nota: A logica de retorno de comando deve ser implementada 
        // no retorno deste metodo para fechar o ciclo com o Python.
    }

    @GetMapping("/atual")
    public LeituraSensor getAtual() {
        return repository.findTopByOrderByDataHoraDesc();
    }

    @GetMapping("/historico")
    public List<LeituraSensor> getHistorico() {
        return repository.findTop20ByOrderByDataHoraDesc();
    }
}
\end{verbatim}
\normalsize

% --- REACT ---
\section{Front-end (React)}
\label{cod:react}

Trecho do componente principal responsável pelo *polling* de dados e envio de comandos manuais.

\small
\begin{verbatim}
  useEffect(() => {
    const buscarDados = async () => {
      try {
        const response = await api.get("/api/sensor/atual");
       
        if (response.data) {
          setTemperaturaAtual(response.data.temperatura || 0);
          setNivelAgua(response.data.nivelOk);
          
          if (response.data.ph) {
            setPhAtual(response.data.ph);
          }

          setPumpActive(response.data.bombaAtiva);
        }
      } catch (error) {
        console.error("Erro ao buscar sensores:", error);
      }
    };

    buscarDados();
    const intervalo = setInterval(buscarDados, 5000); 
    return () => clearInterval(intervalo);
  }, []);

  const handlePumpToggle = async (checked: boolean) => {
    setPumpActive(checked);
   
    const acao = checked ? "LIGAR" : "DESLIGAR";
    try {
        await api.post("/api/sensor/comando-bomba", { ligar: checked });
        toast.success(`Comando: ${acao} enviado`);
    } catch (error) {
        toast.error("Erro ao enviar comando.");
        setPumpActive(!checked);
    }
  };
\end{verbatim}
\normalsize

\end{apendicesenv}