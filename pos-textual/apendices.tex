% ----------------------------------------------------------
% Apêndices
% ----------------------------------------------------------
\begin{apendicesenv}

\partapendices

% ==========================================================
% APÊNDICE A - HARDWARE
% ==========================================================
\chapter{Detalhamento dos Componentes de Hardware}
\label{apendice:hardware}

Neste apêndice são apresentados os componentes físicos utilizados na montagem do protótipo.

\section{Sensores}

\begin{figure}[H]
    \centering
    \caption{Sensor de Temperatura MF58 (NTC 10K)}
    \label{fig:sensortemp}
    \includegraphics[width=0.70\textwidth]{imagens/sensorTemperatura.png}
    \caption*{Fonte: \citeonline{siteComprei}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Sensor de Nível LC26M-40}
    \label{fig:sensorlevel}
    \includegraphics[width=0.60\textwidth]{imagens/sensorNive.png}
    \caption*{Fonte: \citeonline{siteComprei2}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Sensor de pH}
    \label{fig:sensorph}
    \includegraphics[width=0.60\textwidth]{imagens/sensorpH.png}
    \caption*{Fonte: \citeonline{siteCompreiPh}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Sensor de Turbidez ST100}
    \label{fig:sensorturbidez}
    \includegraphics[width=0.60\textwidth]{imagens/sensorTurbidez.png}
    \caption*{Fonte: \citeonline{siteCompreiTurbidez}.}
\end{figure}

\section{Atuadores e Controladores}

\begin{figure}[H]
    \centering
    \caption{Bomba Submersa JT100}
    \label{fig:bombasub}
    \includegraphics[width=0.60\textwidth]{imagens/bombaSubmersa.png}
    \caption*{Fonte: \citeonline{siteComprei}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Placa Arduino Uno R3 (Controlador Físico)}
    \label{fig:arduino}
    \includegraphics[width=0.60\textwidth]{imagens/arduino.png}
    \caption*{Fonte: \citeonline{siteComprei4}.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Raspberry Pi 3 Model B (Gateway)}
    \label{fig:raspberry}
    \includegraphics[width=0.80\textwidth]{imagens/raspBerryQeuUso.png}
    \caption*{Fonte: \citeonline{siteComprei3}.}
\end{figure}

% ==========================================================
% APÊNDICE B - SOFTWARE
% ==========================================================
\chapter{Códigos Fonte do Sistema}
\label{apendice:codigos}

A seguir, são apresentados trechos dos \textit{scripts} desenvolvidos para o sistema de automação, demonstrando integração entre as camadas de \textit{Firmware}, \textit{Gateway} e Aplicação.

% --- ARDUINO ---
\section{Firmware do Microcontrolador (Arduino)}
\label{cod:arduino}

O código abaixo é responsável pela leitura dos sensores em tempo real e controle imediato do relé da bomba, garantindo segurança operacional mesmo sem conexão de rede.

\small
\begin{verbatim}
#define PINO_PH A0        
#define PINO_TEMP A1       
#define PINO_RELE 6       
#define PINO_BOIA 7       

// Configuracao NTC 10k
#define R_FIXO 10000.0     
#define RT0 10000.0        
#define BETA 3950.0        

float calibracao_slope = 0.18; 
int estadoBomba = 0;
bool forcarLigado = false; 

// Variavel para controlar o tempo do envio
unsigned long ultimoEnvio = 0;

void setup() {
  Serial.begin(9600);
  
  pinMode(PINO_PH, INPUT);
  pinMode(PINO_BOIA, INPUT_PULLUP);
  pinMode(PINO_RELE, OUTPUT);        
  
  digitalWrite(PINO_RELE, LOW);    
  Serial.println("INICIO: MODO TURBO ATIVADO");
}

void loop() {
  // 1. LEITURA E CONTROLE IMEDIATO
  if (Serial.available() > 0) {
    char comando = Serial.read();
    if (comando == 'L') forcarLigado = true;
    if (comando == 'D') forcarLigado = false;
  }

  int leituraBoia = digitalRead(PINO_BOIA);
  
  // Logica de Seguranca Local
  bool deveLigar = (leituraBoia == HIGH) || (forcarLigado == true);

  if (deveLigar) { 
      digitalWrite(PINO_RELE, HIGH); 
      estadoBomba = 1; 
  } 
  else { 
      digitalWrite(PINO_RELE, LOW);
      estadoBomba = 0; 
  }

  // 2. ENVIAR DADOS (A CADA 2 SEGUNDOS)
  if (millis() - ultimoEnvio > 2000) {
      ultimoEnvio = millis(); 
      
      // Calculo Temperatura
      float tempCelsius = 0;
      int leituraTemp = analogRead(PINO_TEMP);
      float voltagemTemp = leituraTemp * (5.0 / 1023.0);
      if (voltagemTemp > 0.1 && voltagemTemp < 4.9) {
          float r_termistor = R_FIXO * (5.0 - voltagemTemp) / voltagemTemp;
          float tempKelvin = 1.0 / (1.0 / (273.15 + 25.0) + log(r_termistor / RT0) / BETA);
          tempCelsius = tempKelvin - 273.15;
      }

      // Calculo pH
      long somaLeituras = 0;
      for(int i = 0; i < 10; i++) {
        somaLeituras += analogRead(PINO_PH);
        delay(10); 
      }
      float mediaPH = somaLeituras / 10.0;
      float voltagemPH = mediaPH * (5.0 / 1023.0);
      float valorPH = 7.00 + ((2.50 - voltagemPH) / calibracao_slope);

      // Serializacao JSON
      Serial.print("{\"t\":");
      Serial.print(tempCelsius);
      Serial.print(",\"n\":");
      Serial.print(leituraBoia == HIGH ? 0 : 1); 
      Serial.print(",\"p\":");
      Serial.print(valorPH);
      Serial.print(",\"b\":");
      Serial.print(estadoBomba);
      Serial.println("}");
  }
}
\end{verbatim}
\normalsize

% --- PYTHON ---
\section{Script do Gateway (Python)}
\label{cod:python}

Este \textit{script} roda no Raspberry Pi, atuando como ponte entre a porta Serial (USB) e a API REST.

\small
\begin{verbatim}
import serial
import json
import requests
import time
import sys

# --- CONFIGURACOES ---
PORTA_ARDUINO = '/dev/ttyUSB0' 
VELOCIDADE = 9600
IP_PC = "10.0.0.241" 
URL_BACKEND = f"http://{IP_PC}:8080/api/sensor/receber"

def conectar_arduino():
    while True:
        try:
            print(f" Tentando conectar ao Arduino em {PORTA_ARDUINO}...")
            ser = serial.Serial(PORTA_ARDUINO, VELOCIDADE, timeout=1)
            time.sleep(2) 
            print(" Conectado com sucesso!")
            return ser
        except serial.SerialException:
            print(" Arduino nao encontrado. Tentando de novo em 3s...")
            time.sleep(3)

# --- LOOP PRINCIPAL ---
arduino = conectar_arduino()

while True:
    try:
        if arduino.in_waiting > 0:
            try:
                linha = arduino.readline().decode('utf-8', errors='ignore').strip()
                
                if not linha: continue

                print(f" Enviando: {linha}")
                dados = json.loads(linha)
                
                # Envia e aguarda resposta do comando (Ligar/Desligar)
                resposta = requests.post(URL_BACKEND, json=dados, timeout=2)
                
                if resposta.status_code == 200:
                    try:
                        comando_java = resposta.json()
                        if comando_java.get("ligarBomba") == True:
                            arduino.write(b'L') 
                        elif comando_java.get("ligarBomba") == False:
                            arduino.write(b'D') 
                    except json.JSONDecodeError:
                        pass 
                
            except json.JSONDecodeError:
                pass
            except requests.exceptions.RequestException as e:
                print(f" Erro de conexao com o Java: {e}")

    except (OSError, serial.SerialException):
        if 'arduino' in locals() and arduino.is_open:
            arduino.close()
        arduino = conectar_arduino()
        
    except KeyboardInterrupt:
        if 'arduino' in locals() and arduino.is_open:
            arduino.close()
        break
\end{verbatim}
\normalsize

% --- JAVA ---
\section{\textit{Controller} do \textit{Back-end} (Java/Spring Boot)}
\label{cod:java}

Controlador REST responsável por receber os dados do \textit{Gateway} e persisti-los no banco PostgreSQL.

\small
\begin{verbatim}
package com.ifg.residIFG.controllers;

import com.ifg.residIFG.domain.piscinas.LeituraSensor;
import com.ifg.residIFG.domain.user.User;
import com.ifg.residIFG.dto.SensorDashboardDTO;
import com.ifg.residIFG.repository.LeituraSensorRepository;
import com.ifg.residIFG.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/sensor")
@CrossOrigin(origins = "*")
public class SensorController {

    @Autowired
    private LeituraSensorRepository repository;
    @Autowired
    private UserRepository userRepository;

    @PostMapping("/receber")
    public void receberDados(@RequestBody Map<String, Object> dados) {
        Double temp = Double.valueOf(dados.get("t").toString());
        Integer nivelRaw = Integer.valueOf(dados.get("n").toString());
        Boolean nivel = (nivelRaw == 1);
        Double ph = Double.valueOf(dados.get("p").toString());
        Integer bombaRaw = Integer.valueOf(dados.get("b").toString());
        Boolean bombaAtiva = (bombaRaw == 1);

        // Leitura de Turbidez (tb) com tratamento de nulo
        Double turbidez = 0.0;
        if (dados.get("tb") != null) {
            turbidez = Double.valueOf(dados.get("tb").toString());
        }

        LeituraSensor leitura = new LeituraSensor(temp, nivel, ph, bombaAtiva, turbidez);
        repository.save(leitura);
    }

    @GetMapping("/atual")
    public SensorDashboardDTO getAtual() {
        // 1. Busca a ultima leitura do sensor
        LeituraSensor leitura = repository.findTopByOrderByDataHoraDesc();

        // 2. Busca dimensoes do usuario para calculo de volume
        List<User> users = userRepository.findAll();
        Double volumeCalculado = 0.0;

        if (!users.isEmpty()) {
            User unicoUsuario = users.get(0); 
            // Formula: (Comp * Larg * Prof) * 1000 = Litros
            float v = unicoUsuario.getComprimentoPiscina() * unicoUsuario.getLarguraPiscina() * unicoUsuario.getProfundidadePiscina();
            volumeCalculado = (double) (v * 1000);
        }

        // Retorna DTO com dados do sensor + volume calculado
        return new SensorDashboardDTO(leitura, volumeCalculado);
    }
}
\end{verbatim}
\normalsize

% --- REACT ---
\section{Front-end (React)}
\label{cod:react}

Trecho do componente principal responsável pelo \textit{polling} de dados e envio de comandos manuais.

\small
\begin{verbatim}
  useEffect(() => {
    const buscarDados = async () => {
      try {
        const response = await api.get("/api/sensor/atual");
       
        if (response.data) {
          setTemperaturaAtual(response.data.temperatura || 0);
          setNivelAgua(response.data.nivelOk);
          
          if (response.data.ph) {
            setPhAtual(response.data.ph);
          }

          setPumpActive(response.data.bombaAtiva);
        }
      } catch (error) {
        console.error("Erro ao buscar sensores:", error);
      }
    };

    buscarDados();
    const intervalo = setInterval(buscarDados, 5000); 
    return () => clearInterval(intervalo);
  }, []);

  const handlePumpToggle = async (checked: boolean) => {
    setPumpActive(checked);
   
    const acao = checked ? "LIGAR" : "DESLIGAR";
    try {
        await api.post("/api/sensor/comando-bomba", { ligar: checked });
        toast.success(`Comando: ${acao} enviado`);
    } catch (error) {
        toast.error("Erro ao enviar comando.");
        setPumpActive(!checked);
    }
  };
\end{verbatim}
\normalsize

\end{apendicesenv}

% --- REACT ---

\section{Algoritmo de Recomendação Química e Alertas (React)}
\label{cod:react_logic}

O trecho abaixo apresenta a função \texttt{verificarQuimica} na camada de aplicação. Este algoritmo compara os dados monitorados com as normas sanitárias e com as configurações do usuário, gerando as sugestões de dosagem proporcionais ao volume calculado.

\small
\begin{verbatim}
  // Algoritmo de Recomendacao de Dosagem e Alertas
  const verificarQuimica = (ph: number, turbidez: number, 
                            temp: number, volLitros: number) => {
    
    // Verifica tempo de silencio (Cooldown de alertas para nao spammar)
    if (Date.now() < proximoAlerta) return; 

    let produto = "";
    let dosagemPor1000 = 0;
    let motivo = "";

    // 1. Logica de Correcao de pH (Tabela de Referencia)
    if (ph < 6.8) {
      produto = "pH+ (Liquido)";
      motivo = "pH muito baixo (< 6.8)";
      dosagemPor1000 = 20; 
    } else if (ph >= 6.8 && ph < 7.2) { 
       if (ph <= 7.0) {
          produto = "pH+ (Liquido)";
          motivo = "pH levemente baixo";
          dosagemPor1000 = 15; 
       }
    } else if (ph > 7.6) {
      produto = "pH- (Liquido)";
      motivo = "pH alto (> 7.6)";
      dosagemPor1000 = 10; 
    }
    
    // 2. Logica de Turbidez (Clarificacao se > 3.0 NTU)
    else if (turbidez > 3.0) {
      produto = "Clarificante";
      motivo = `Agua turva (${turbidez} NTU)`;
      dosagemPor1000 = 4;
    }
    
    // 3. Alerta de Temperatura (Baseado na Configuracao do Usuario)
    else if (temp < minTempConfig) {
       toast({
         title: "Temperatura Baixa",
         description: `Atual: ${temp}°C (Minimo: ${minTempConfig}°C)`,
       });
       // Define cooldown curto para temperatura
       setProximoAlerta(Date.now() + (5 * 60 * 1000));
       return; 
    }

    // Calculo Final e Disparo da Sugestao
    if (produto !== "") {
      const qtdTotal = (volLitros / 1000) * dosagemPor1000;
      
      const tempoSilencio = 20 * 60 * 1000; // 20 min sem repetir
      setProximoAlerta(Date.now() + tempoSilencio);

      toast({
        variant: "destructive",
        title: `Atencao: ${motivo}`,
        description: `Clique para ver a correcao.`,
        action: (
          <ToastAction altText="Ver Dosagem" 
                       onClick={() => setIsModalOpen(true)}>
            Ver Dosagem
          </ToastAction>
        ),
      });
    }
  };
\end{verbatim}
\normalsize