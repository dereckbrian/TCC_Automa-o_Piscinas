\chapter{Desenvolvimento}

\section{Tipo de Pesquisa e Etapas de Construção}

A pesquisa caracteriza-se como aplicada, de abordagem mista e de natureza exploratória e experimental. Inicialmente, foi realizado um estudo teórico sobre automação residencial, sensores, atuadores e controladores associados à Internet das Coisas (IoT), fundamentado nos autores apresentados no \autoref{cap:fundamentacao}. Essa etapa possibilitou a compreensão dos processos físico-químicos envolvidos no tratamento da água, das normas sanitárias aplicáveis e dos requisitos técnicos necessários para a integração entre hardware, software e dispositivos embarcados.

O levantamento bibliográfico incluiu artigos científicos, manuais técnicos e normas da Associação Brasileira de Normas Técnicas (ABNT), assegurando base conceitual e técnica suficiente para orientar as decisões posteriores de arquitetura, modelagem e implementação do sistema. Os critérios adotados para a seleção das fontes contemplaram a atualidade das informações, priorizando publicações dos últimos dez anos para temas relacionados à tecnologia, automação residencial e Internet das Coisas (IoT); a relevância técnica, com a utilização de manuais de fabricantes e guias especializados para fundamentar os processos físico-químicos de tratamento da água; e a robustez teórica, com a seleção de autores consolidados e trabalhos acadêmicos reconhecidos nas áreas de Engenharia de Software e arquitetura de sistemas.

Essa etapa inicial permitiu mapear os requisitos técnicos necessários à integração entre hardware, software e dispositivos embarcados, fornecendo subsídios consistentes para orientar as decisões de projeto adotadas ao longo do desenvolvimento do sistema.

\section{Processo de Desenvolvimento de Software}

Neste projeto, adotou-se o \textit{Rational Unified Process} (RUP) como metodologia de desenvolvimento, em razão de sua estrutura iterativa e incremental, do foco na mitigação de riscos e da ênfase na modelagem e na documentação do software. Conforme apresentado na fundamentação teórica, o RUP organiza o processo de engenharia de software em quatro fases principais: Concepção, Elaboração, Construção e Transição. Cada fase possui objetivos específicos que orientam a evolução do sistema, assegurando a rastreabilidade entre requisitos, arquitetura e implementação.

Considerando que o sistema desenvolvido envolve automação e dispositivos IoT, o ciclo de vida do desenvolvimento de hardware foi adaptado às fases do RUP. Nesse contexto, a definição e a seleção dos componentes eletrônicos ocorreram durante a fase de Concepção, enquanto a montagem física e a calibração dos sensores foram realizadas de forma integrada à fase de Construção, em paralelo à implementação do software.

A adoção dessa metodologia estabelece um fluxo contínuo de desenvolvimento, no qual cada artefato produzido em uma fase serve como base para a validação da fase subsequente. Assim, os requisitos levantados na fase de Concepção subsidiam a modelagem arquitetural realizada na fase de Elaboração, cujos diagramas orientam a implementação na fase de Construção. Por fim, a conformidade do sistema desenvolvido é verificada durante a fase de Transição, por meio de testes funcionais e ajustes finais.

As subseções seguintes descrevem detalhadamente cada uma dessas fases, destacando as atividades executadas e sua relação com os artefatos produzidos ao longo do processo.

\section{Fase de Concepção (\textit{Inception})}

Na fase de Concepção foram definidos o problema de pesquisa, o escopo inicial do projeto e os requisitos fundamentais do sistema. O problema identificado refere-se às dificuldades enfrentadas pelos usuários no processo manual de manutenção de piscinas, decorrentes da necessidade de medições frequentes, cálculos físico-químicos, além do risco de desperdício de produtos ocasionado pela aplicação imprecisa das dosagens recomendadas.

Com o objetivo de mitigar essas limitações, o sistema foi concebido para automatizar a leitura contínua dos principais parâmetros físico-químicos da água, reduzir a subjetividade na avaliação da qualidade, atuar de forma autônoma no sistema de filtragem com base na turbidez e disponibilizar interfaces remotas para monitoramento e acompanhamento do processo de manutenção.

O levantamento de requisitos resultou na definição dos requisitos funcionais (RF) e não funcionais (RNF), apresentados nas Tabelas \ref{tab:req_funcionais} e \ref{tab:req_nao_funcionais}, respectivamente.

\begin{table}[H]
    \centering
    \caption{Requisitos Funcionais do Sistema de Automação de Piscinas}
    \label{tab:req_funcionais}
    \begin{tabularx}{\textwidth}{l X}
    \toprule
    \textbf{Código} & \textbf{Descrição} \\
    \midrule
    \textbf{RF01} & O sistema deve monitorar automaticamente os níveis de pH, turbidez, temperatura e nível da água. \\
    \addlinespace
    \textbf{RF02} & O sistema deve acionar automaticamente a bomba de água conforme os parâmetros coletado pelo sensor de nível. \\
    \addlinespace
    \textbf{RF03} & O sistema deve disponibilizar uma interface web para visualização dos parâmetros monitorados. \\
    \addlinespace
    \textbf{RF04} & O sistema deve permitir o cadastro e o armazenamento dos dados coletados no banco de dados. \\
    \addlinespace
    \textbf{RF05} & O sistema deve emitir alertas quando algum parâmetro ultrapassar os limites estabelecidos. \\
    \addlinespace
    \textbf{RF06} & O sistema deve gerar gráficos com base nos dados históricos dos parâmetros monitorados. \\
    \bottomrule
    \end{tabularx}
    \caption*{Fonte: Autoria própria (2025).}
\end{table}

Para a validação dos requisitos definidos, foram estabelecidos critérios quantitativos de aceitação, considerando o desempenho esperado para um protótipo IoT. A precisão dos sensores (RF01) foi definida com margem de erro inferior a $\pm$5\% em relação a medições de referência. Quanto ao desempenho temporal, estabeleceu-se que o tempo de latência total, compreendido entre a aquisição do dado físico pelo microcontrolador e sua visualização na interface web, não deve exceder cinco segundos, caracterizando uma monitoração em tempo quase real. No que se refere à comunicação (RNF03), o sistema é considerado estável quando as requisições HTTP apresentam taxa de sucesso superior a 95\% em operação contínua, com tempo de resposta do servidor inferior a quatro segundos por requisição. O requisito de automação (RF02) é considerado atendido quando o acionamento do atuador ocorrer em até dois segundos após a detecção da falta de água.

\begin{table}[H]
    \centering
    \caption{Requisitos Não Funcionais do Sistema de Automação de Piscinas}
    \label{tab:req_nao_funcionais}
    \begin{tabularx}{\textwidth}{l X}
    \toprule
    \textbf{Código} & \textbf{Descrição} \\
    \midrule
    \textbf{RNF01} & O sistema deve utilizar o banco de dados PostgreSQL para armazenamento das informações. \\
    \addlinespace
    \textbf{RNF02} & A interface web deve ser responsiva e acessível em dispositivos móveis e desktops. \\
    \addlinespace
    \textbf{RNF03} & A comunicação entre o gateway (Raspberry Pi) e o servidor deve ocorrer utilizando o protocolo HTTP. \\
    \addlinespace
    \textbf{RNF04} & O sistema deve ser desenvolvido utilizando o framework Spring Boot no back-end e React no front-end. \\
    \bottomrule
    \end{tabularx}
    \caption*{Fonte: Autoria própria (2025).}
\end{table}

Para atender ao escopo definido, adotou-se uma arquitetura distribuída de hardware e software. Na camada física, selecionou-se o Arduino Uno para a leitura dos sensores e o acionamento dos atuadores, enquanto o Raspberry Pi foi designado para a comunicação entre o microcontrolador, o servidor e a aplicação web. Na camada de software, definiu-se o uso do framework Spring Boot no back-end, em virtude de sua robustez na implementação de APIs REST, React para o desenvolvimento da interface web responsiva e PostgreSQL para a persistência e o gerenciamento dos dados coletados.
\section{Fase de Elaboração (\textit{Elaboration})}

Com o objetivo de mitigar riscos técnicos e validar as principais decisões arquiteturais do sistema, foram desenvolvidos protótipos funcionais parciais, conforme recomendado pelo Rational Unified Process (RUP). Nessa etapa, realizaram-se testes preliminares de integração entre os sensores, o microcontrolador Arduino e o Raspberry Pi, com foco na verificação da estabilidade da comunicação serial, da latência no envio de dados e da viabilidade da arquitetura proposta. Esses experimentos permitiram confirmar que a infraestrutura de hardware selecionada atende aos requisitos de desempenho estabelecidos na fase de Concepção.

Simultaneamente, foram definidos os principais artefatos estruturais do sistema, incluindo a modelagem dos casos de uso, a arquitetura de comunicação entre os dispositivos físicos e a especificação dos componentes embarcados que compõem o protótipo. Dessa forma, a fase de Elaboração estabelece a ligação entre os requisitos identificados na Concepção e a implementação conduzida na fase de Construção, assegurando que o sistema seja desenvolvido com base em uma arquitetura previamente validada e devidamente documentada.

\subsection*{Modelagem de Caso de Uso}

A modelagem de casos de uso, elaborada segundo a Linguagem de Modelagem Unificada (UML), fornece uma visão geral das interações entre os atores e as funcionalidades principais do sistema. O diagrama permite compreender como o usuário acessa as informações coletadas, como interage com o sistema por meio da interface web e como os dispositivos físicos se integram às operações lógicas implementadas no back-end.

\begin{figure}[H]
    \centering
    \caption{Diagrama de Caso de Uso do Sistema}
    \label{fig:usecase}
    \includegraphics[width=1.00\textwidth]{imagens/meuDiagramaTcc.png}
    \caption*{Fonte: Autoria própria (2025).}
\end{figure}

\subsection*{Arquitetura Geral do Sistema}

O sistema foi concebido a partir de uma arquitetura distribuída, composta por sensores, um microcontrolador Arduino, um microcomputador Raspberry Pi, um back-end desenvolvido com o framework Spring Boot e uma interface web implementada em React. O fluxo principal de funcionamento do sistema ocorre conforme as seguintes etapas:

\begin{enumerate}
    \item Coleta dos dados pelos sensores conectados ao Arduino;
    \item Transmissão das leituras do Arduino para o Raspberry Pi;
    \item Envio periódico das informações ao servidor por meio de requisições HTTP;
    \item Armazenamento dos dados no banco de dados PostgreSQL;
    \item Apresentação dos parâmetros ao usuário por meio da interface web.
\end{enumerate}

Essa arquitetura favorece a escalabilidade e o desacoplamento entre as camadas do sistema, em conformidade com os princípios discutidos no \autoref{cap:fundamentacao}. Entretanto, a distribuição dos componentes físicos introduz riscos operacionais relevantes, como a dependência da integridade funcional de múltiplos dispositivos. A falha de um único nó, seja um sensor ou um controlador, pode comprometer temporariamente o fluxo de dados.

Além disso, a comunicação baseada em protocolos HTTP está sujeita a latências e instabilidades de rede, especialmente em infraestruturas domésticas, o que exige a implementação de mecanismos de tratamento de exceções, tentativas de reconexão automática e tolerância a falhas. Tais estratégias são fundamentais para garantir que o sistema seja capaz de recuperar sua operabilidade sem a necessidade de intervenção humana após falhas momentâneas de conectividade.

\subsection*{Componentes Utilizados no Sistema}

A seguir, são apresentados os principais componentes físicos selecionados para o desenvolvimento do protótipo, incluindo sensores, atuadores e dispositivos de controle. A definição desses elementos nesta fase está alinhada ao RUP, uma vez que a Elaboração contempla a consolidação da arquitetura física e lógica do sistema. 

\subsubsection*{Sensores de Monitoramento}

Para a medição da temperatura da água, optou-se pelo sensor NTC 10K (Modelo MF58), ilustrado na Figura \ref{fig:sensortemp} (Apêndice \ref{apendice:hardware}). Este termistor altera sua resistência elétrica inversamente à temperatura e é lido por uma porta analógica do Arduino através de um divisor de tensão.

O monitoramento do nível da água é realizado pelo sensor LC26M-40, apresentado na Figura \ref{fig:sensorlevel} (Apêndice \ref{apendice:hardware}). Fabricado em polipropileno, seu funcionamento baseia-se em um interruptor magnético (\textit{reed switch}) acionado pelo deslocamento de um flutuador, fornecendo um sinal digital (SPST) para identificar níveis críticos no reservatório.

A qualidade química da água é aferida por um Sensor de pH (Figura \ref{fig:sensorph}, Apêndice \ref{apendice:hardware}) e um Sensor de Turbidez Modelo ST100 (Figura \ref{fig:sensorturbidez}, Apêndice \ref{apendice:hardware}). O sensor de pH monitora a acidez, enquanto o sensor de turbidez identifica partículas em suspensão. Ambos geram sinais analógicos processados pelo Arduino e enviados ao servidor para análise e tomada de decisão.

\subsubsection*{Atuadores}

Para o controle do fluxo de água, foram utilizadas bombas submersas modelo JT100 (3V a 5V), conforme detalhado na Figura \ref{fig:bombasub} (Apêndice \ref{apendice:hardware}). Com vazão entre 1000 e 1500 ml/min e elevação de até 1 metro, estes equipamentos são responsáveis pela filtragem e acionamento da cascata no protótipo.

\subsubsection*{Controladores e Gateway}

O controle direto de hardware é exercido pela placa Arduino Uno R3 (Figura \ref{fig:arduino}, Apêndice \ref{apendice:hardware}). Sua escolha deve-se à robustez nas leituras analógicas e à vasta disponibilidade de bibliotecas para controle dos atuadores em tempo real.

Como elemento intermediário (\textit{Gateway}), utiliza-se o Raspberry Pi 3 Model B, exibido na Figura \ref{fig:raspberry} (Apêndice \ref{apendice:hardware}). Equipado com processador, ele gerencia a comunicação Serial com o Arduino e executa os \textit{scripts} responsáveis pelo envio dos dados à API, isolando a lógica de rede da lógica de controle físico.

\begin{table}[H]
    \centering
    \caption{Resumo das Especificações Técnicas dos Componentes de Hardware}
    \label{tab:resumo_hardware}
    \begin{tabularx}{\textwidth}{l >{\raggedright\arraybackslash}X c >{\raggedright\arraybackslash}X}
    \toprule
    \textbf{Componente} & \textbf{Função Principal} & \textbf{Tensão} & \textbf{Comunicação / Sinal} \\
    \midrule
    Raspberry Pi 3 B & Gateway de comunicação e envio de dados ao servidor & 5\,V & Serial (USB) / Wi-Fi (HTTP) \\
    \addlinespace
    Arduino Uno R3 & Leitura de sensores e controle de atuadores & 5\,V / 9\,V & Serial / I/O digital e analógico \\
    \addlinespace
    Sensor de Temperatura (NTC) & Monitoramento térmico da água & 5\,V & Analógico (divisor de tensão) \\
    \addlinespace
    Sensor de Nível & Detecção de nível crítico do reservatório & 5\,V & Digital (On/Off) \\
    \addlinespace
    Sensor de pH & Medição da acidez e alcalinidade da água & 5\,V & Analógico \\
    \addlinespace
    Sensor de Turbidez & Avaliação da transparência da água & 5\,V & Analógico \\
    \addlinespace
    Bomba Submersa & Circulação e filtragem da água & 3--6\,V & Acionamento via relé (sinal digital) \\
    \bottomrule
    \end{tabularx}
    \caption*{Fonte: Autoria própria (2025).}
\end{table}

\section{Fase de Construção (\textit{Construction})}

Em conformidade com a metodologia RUP, a fase de Construção foi conduzida por meio de ciclos iterativos e incrementais, nos quais funcionalidades do sistema foram implementadas e validadas progressivamente. O desenvolvimento iniciou-se pela camada física, com a implementação e a validação individual dos sensores e atuadores conectados ao microcontrolador. Após a estabilização da aquisição dos dados, procedeu-se à implementação da camada lógica, englobando o back-end, o banco de dados e o front-end. 

A etapa final concentrou-se na integração completa entre hardware e software, validando o fluxo de transmissão das informações desde a coleta no ambiente físico até a apresentação na interface web.O desenvolvimento do sistema foi estruturado em duas camadas principais: a camada embarcada, responsável pela leitura, pré-processamento e envio dos dados coletados; e a camada de aplicação, encarregada de receber, armazenar e disponibilizar essas informações aos usuários.

Na camada embarcada, o Arduino foi programado por meio de sua IDE nativa para realizar a leitura dos sensores analógicos e digitais, bem como o acionamento condicional dos atuadores. A montagem física e a organização dos componentes durante os testes de bancada podem ser visualizadas na Figura \ref{fig:testes_bancada}.

\begin{figure}[H]
    \centering
    \caption{Testes em bancada}
    \label{fig:testes_bancada}
    \includegraphics[width=0.6\textwidth]{imagens/prototipoMesa.jpeg}
    \caption*{Fonte: Autoria própria (2025).}
\end{figure}

Conforme apresentado no Apêndice \ref{apendice:codigos}, a Seção \ref{cod:arduino} ilustra a rotina de coleta dos parâmetros da água e a lógica empregada para o controle dos dispositivos físicos.

Com o intuito de  garantir a confiabilidade das informações coletadas e evitar o armazenamento de dados incorretos, foi desenvolvido um fluxo lógico de validação e normalização antes da persistência no banco de dados. A Figura \ref{fig:fluxo_logica} demonstra o algoritmo de decisão executado pelo sistema a cada ciclo de leitura.

\begin{figure}[H]
    \centering
    \caption{Fluxograma de validação de dados e tomada de decisão do sistema}
    \label{fig:fluxo_logica}
    \includegraphics[width=0.6\textwidth]{imagens/diagramaFluxo.png}
    \caption*{Fonte: Autoria própria (2025).}
\end{figure}

O Raspberry Pi desempenhou a função de \textit{gateway} de comunicação do sistema. Um \textit{script} desenvolvido em Python foi responsável por estabelecer a comunicação serial com o microcontrolador, interpretar os dados recebidos e encaminhá-los ao servidor por meio de requisições HTTP do tipo POST. A lógica de implementação desse \textit{gateway}, incluindo os mecanismos de tratamento de falhas de comunicação e a serialização dos dados em formato JSON, encontra-se detalhada no Apêndice \ref{apendice:codigos}, Seção \ref{cod:python}.

Na camada de aplicação, o \textit{back-end}, implementado com o \textit{framework} Spring Boot, disponibiliza os \textit{endpoints} necessários para a recepção e a persistência dos dados coletados. O \textit{controller} responsável por mapear as requisições, converter os objetos JSON e armazenar as leituras no banco de dados PostgreSQL está apresentado no Apêndice \ref{apendice:codigos}, Seção \ref{cod:java}. Essa arquitetura centraliza a regra de negócios, assegurando a integridade, a consistência e a disponibilidade do histórico de monitoramento.

Por fim, a interface do usuário, desenvolvida em React, consome os dados fornecidos pela API para apresentar o estado atual da piscina em tempo quase real. A implementação da lógica de consumo da API e o gerenciamento de estado para visualização dos parâmetros e acionamento manual dos atuadores estão descritos no Apêndice \ref{apendice:codigos}, Seção \ref{cod:react}.

\section{Fase de Transição (\textit{Transition})}

Na fase de Transição, o sistema desenvolvido foi submetido a testes práticos com o objetivo de validar seu desempenho, estabilidade e conformidade com os requisitos estabelecidos nas fases anteriores. Foram realizados testes unitários nos sensores, abrangendo a calibração do sensor NTC de temperatura e pH, a verificação da estabilidade do sensor de nível e simulações de condições críticas de funcionamento das bombas, de modo a prevenir situações de \textit{dry-run}. Paralelamente, testes de integração avaliaram o fluxo completo dos dados, desde a aquisição no ambiente físico até a apresentação das informações na interface web.

\begin{table}[H]
    \centering
    \caption{Resumo dos Testes de Validação Sistêmica}
    \label{tab:testes_realizados}
    \begin{tabularx}{\textwidth}{ >{\raggedright\arraybackslash}p{4cm} >{\raggedright\arraybackslash}X >{\raggedright\arraybackslash}p{3.5cm} }
    \toprule
    \textbf{Teste Realizado} & \textbf{Objetivo do Teste} & \textbf{Critério/Resultado} \\
    \midrule
    Calibração do Sensor NTC & Verificar a precisão térmica por comparação com termômetro de referência & Margem de erro aceitável ($<\pm 1^{\circ}$C) \\
    \addlinespace
    Calibração do pH & Ajuste de ganho via \textit{trimpot} do módulo comparado com valor de referência & Erro absoluto médio $< 0,1$ pH \\
    \addlinespace
    Estabilidade do Nível & Confirmar o acionamento da boia sem oscilações espúrias & \textit{Debounce} lógico funcional \\
    \addlinespace
    Integração de Dados & Validar o fluxo completo Arduino $\rightarrow$ Raspberry Pi $\rightarrow$ Banco de Dados & Persistência verificada no PostgreSQL \\
    \addlinespace
    Latência da Interface & Medir o tempo entre a leitura do sensor e a atualização na interface web & Atualização em tempo quase real ($<$ 5s) \\
    \bottomrule
    \end{tabularx}
    \caption*{Fonte: Autoria própria (2025).}
\end{table}

Adicionalmente, foram realizados testes de responsividade da interface web e de confiabilidade da comunicação entre o servidor e os dispositivos embarcados. Os ajustes finais envolveram a correção de algoritmos de conversão dos sensores, a adequação de temporizações de leitura e transmissão, bem como melhorias na visualização gráfica dos dados apresentados ao usuário.

Embora os testes tenham validado a funcionalidade do sistema, observaram-se limitações decorrentes da escala reduzida do protótipo. A discussão detalhada sobre esses desafios e o desempenho quantitativo do sistema será apresentada a seguir.

% A principal restrição técnica observada refere-se à calibração fina dos sensores analógicos de turbidez e pH, os quais apresentaram sensibilidade a ruídos elétricos e variações ambientais, demandando tratamento adicional dos sinais por meio de filtragem e normalização em software. Tais limitações evidenciam que, embora o sistema atenda aos requisitos funcionais propostos, sua precisão pode ser impactada por fatores externos em cenários de uso prolongado.

% Outro aspecto relevante diz respeito à dependência da infraestrutura de rede local. Falhas momentâneas de conectividade podem ocasionar atrasos ou lacunas temporárias no monitoramento em tempo real, ainda que não comprometam o armazenamento posterior dos dados. Esse comportamento reforça a necessidade de estratégias adicionais de tolerância a falhas, como armazenamento local temporário e mecanismos de retransmissão automática.


