\chapter{Desenvolvimento}

% =======================
% SEÇÃO 3.1 — TIPO DE PESQUISA E ETAPAS
% =======================

\section{Tipo de Pesquisa e Etapas de Construção}

A pesquisa caracteriza-se como aplicada, de abordagem mista e natureza exploratória e experimental. Inicialmente, foi conduzido um estudo teórico sobre automação residencial, sensores, atuadores e controladores IoT, fundamentado em autores apresentados no Capítulo 2. Essa etapa permitiu compreender os processos físico-químicos envolvidos no tratamento da água, as normas sanitárias aplicáveis e os requisitos técnicos necessários para a integração entre hardware, software e dispositivos embarcados.

% Inserir após este parágrafo uma breve problematização das limitações dos métodos manuais (ex.: falta de precisão, riscos sanitários, dependência da experiência do usuário).
% Objetivo: fortalecer a justificativa metodológica da automação e conectar com o Capítulo 2.        (FEITO)

A motivação principal desta pesquisa surge das limitações significativas associadas à limpeza manual de piscinas, que envolvem uma série de desafios e riscos. Primeiramente, há o risco à saúde dos usuários, uma vez que a limpeza inadequada pode comprometer a qualidade da água, criando condições propícias para o crescimento de microrganismos prejudiciais à saúde. Além disso, a falta de precisão no momento de adicionar produtos químicos à piscina pode resultar no desperdício desses produtos, prejudicando tanto a eficácia do tratamento quanto gerando custos desnecessários. Por fim, a limpeza de piscinas ainda depende fortemente do conhecimento de quem realiza o processo, o que cria uma dependência de profissionais qualificados. Isso significa que, em muitas situações, indivíduos sem a experiência necessária precisam contar com a ajuda de outros, o que pode gerar dificuldades operacionais e inconsistências na qualidade da manutenção.

O levantamento bibliográfico incluiu artigos científicos, manuais técnicos, normas da ABNT e documentos da ANVISA, garantindo base técnica suficiente para orientar as decisões posteriores de arquitetura, modelagem e implementação do sistema. Os critérios escolhidos para seleção das fontes bibliográficas foram: a atualidade das informações, priorizando-se publicações dos últimos cinco anos para temas relacionados à tecnologia, mercado de automação e Internet das Coisas (\textit{IoT}); a relevância técnica, com o uso de manuais de fabricantes e guias especializados para fundamentar os processos físico-químicos de tratamento da água; e a robustez teórica, buscando-se autores consolidados e trabalhos acadêmicos reconhecidos para embasar as metodologias de Engenharia de Software e arquitetura de sistemas.

% Aqui ainda cabe acrescentar uma frase explicando o critério de seleção das fontes (relevância técnica, atualidade, normalização).
% Isso deixa a metodologia mais robusta.       (FEITO)


% =======================
% SEÇÃO 3.2 — RUP
% =======================

\section{Processo de Desenvolvimento de Software}

Neste projeto, adotou-se o Rational Unified Process (RUP) como metodologia de desenvolvimento devido à sua estrutura iterativa e incremental, ao foco na mitigação de riscos e à ênfase na modelagem e documentação. Conforme exposto na fundamentação teórica, o RUP organiza o processo de engenharia de software em quatro fases principais: Concepção, Elaboração, Construção e Transição. Cada fase apresenta objetivos específicos que orientam a evolução do sistema, garantindo rastreabilidade entre requisitos, arquitetura e implementação.

A escolha dessa metodologia consolida um fluxo contínuo durante o desenvolvimento, no qual cada artefato produzido em uma fase é responsável por validar a etapa seguinte. Dessa forma, o levantamento de requisitos realizado na fase de Concepção serve como base para a modelagem arquitetural na fase de Elaboração, com os diagramas orientando o desenvolvimento do sistema na fase de Construção. Por fim, a conformidade do software desenvolvido é verificada durante a fase de Transição.

As subseções seguintes descrevem cada etapa, destacando as atividades realizadas e sua relação com os artefatos produzidos.

% Introduzir aqui uma frase de ligação explicando que cada fase do RUP produzirá artefatos específicos validados na fase seguinte.
% Isso reforça coerência metodológica.       (FEITO)


% =======================
% SEÇÃO 3.3 — INCEPTION 
% =======================

\section{Fase de Concepção (\textit{Inception})}

Nesta fase, foram definidos o problema, o escopo inicial do projeto e os requisitos fundamentais. O problema identificado consiste na dificuldade encontradas por usuários no processo manual de manutenção de piscinas, devido à necessidade de medições constantes, cálculos físicos e químicos, além da possibilidade de desperdício de produtos decorrente da aplicação incorreta das dosagens.

Diante disso, a execução inadequada dos processos de limpeza acarreta riscos diretos à integridade dos usuários e dos equipamentos. Segundo a literatura técnica, a falha no controle do pH é crítica: valores abaixo de 7,2 provocam irritações imediatas na pele e nos olhos dos banhistas, além de acelerar a corrosão de tubulações e componentes metálicos. Já a manutenção de um pH acima de 7,8, comum em correções manuais imprecisas, reduz drasticamente a eficácia dos agentes sanitizantes, comprometendo a desinfecção da água.

% Recomendo adicionar aqui dados estimados (literatura) sobre erros comuns na manutenção manual:
% - subdosagem de cloro
% - sobrecorreção de pH
% - riscos sanitários
% Isso fortalecerá a crítica e a motivação científica.      (FEITO)

A partir dessa análise, concebeu-se o sistema de automação com base nos seguintes objetivos: automatizar a leitura dos principais parâmetros da água; reduzir o uso inadequado de produtos químicos; otimizar o acionamento dos mecanismos de filtragem; e fornecer ao usuário meios de visualização e interação com os dados.


O levantamento de requisitos resultou nos seguintes requisitos funcionais e não funcionais, apresentados nas Tabelas \ref{tab:req_funcionais} e \ref{tab:req_nao_funcionais}, respectivamente.

% Ainda falta criar critérios objetivos de aceitação dos requisitos.
% Sugestão: após as tabelas, adicionar parágrafo explicando métricas:
% - Faixa de erro aceitável dos sensores
% - Tempo máximo entre coleta e exibição
% - Limite de latência nas requisições
% - Condições para considerar um requisito atendido     (FEITO)

\begin{table}[H] 
    \centering \caption{Requisitos Funcionais do Sistema de Automação de Piscinas.} 
    \label{tab:req_funcionais} 
    \begin{tabular}{|p{1.5cm}|p{11cm}|} 
    \hline\textbf{Código} & \textbf{Descrição} \\ 
    \hline \textbf{RF01} & O sistema deve monitorar automaticamente os níveis de pH, turbidez, temperatura e nível da água. \\ 
    \hline \textbf{RF02} & O sistema deve acionar automaticamente a bomba de filtragem e o aquecedor conforme os parâmetros definidos ou coletados pelos sensores. \\ 
    \hline \textbf{RF03} & O sistema deve disponibilizar uma interface web para visualização dos parâmetros monitorados. \\ \hline \textbf{RF04} & O sistema deve permitir o cadastro e armazenamento dos dados coletados no banco de dados. \\ 
    \hline \textbf{RF05} & O sistema deve permitir o cadastro de piscinas vinculadas a usuários. \\ 
    \hline \textbf{RF06} & O sistema deve emitir alertas quando algum parâmetro ultrapassar o limite ideal. \\ 
    \hline \textbf{RF06} & O sistema deve emitir gráficos de acordo com os ultimos dados de determinadas parâmetros coletados. \\ \hline
    \end{tabular}
    \caption*{Fonte: Autoria própria.}
\end{table}

Para a validação dos requisitos elencados, foram estabelecidos critérios quantitativos de aceitação baseados no desempenho esperado para um protótipo IoT. Determinou-se que a precisão dos sensores (RF01) deve operar com margem de erro inferior a ±5\% em comparação a medições de referência. Quanto ao desempenho temporal, estabeleceu-se que o tempo de latência total, compreendido entre a aquisição do dado físico pelo microcontrolador e sua visualização na interface web, não deve exceder 5 segundos, garantindo a monitoração em tempo quase real. No que tange à comunicação (RNF04), considera-se o sistema estável se as requisições HTTP apresentarem taxa de sucesso superior a 95\% em operação contínua, com tempo de resposta do servidor inferior a 4 segundo por requisição. Por fim, o requisito de automação (RF02) será considerado atendido se o acionamento dos atuadores (bombas) ocorrer em até 2 segundos após a detecção de uma condição crítica parametrizada no sistema.

\vspace{0.5cm} 

\begin{table}[H] 
    \centering \caption{Requisitos Não Funcionais do Sistema de Automação de Piscinas.} 
    \label{tab:req_nao_funcionais} 
    \begin{tabular}{|p{1.5cm}|p{11cm}|} 
    \hline \textbf{Código} & \textbf{Descrição} \\ 
    \hline \textbf{RNF01} & O sistema deve utilizar o banco de dados PostgreSQL para armazenamento das informações. \\ 
    \hline \textbf{RNF02} & A interface web deve ser responsiva e acessível em dispositivos móveis e desktops. \\ 
    \hline \textbf{RNF03} & A comunicação entre o microcontrolador e o servidor deve ocorrer de forma segura, utilizando protocolos HTTP. \\ 
    \hline \textbf{RNF04} & O sistema deve ser desenvolvido com o framework Spring Boot no back-end e React no front-end. \\ 
    \hline 
    \end{tabular}
    \caption*{Fonte: Autoria própria.}
\end{table}

As tecnologias selecionadas para atender ao escopo inicial incluíram o Raspberry Pi como dispositivo de controle, sensores de pH, nível e temperatura, o framework React para interface web e PostgreSQL como banco de dados. O uso do Spring Boot no \textit{back-end} foi definido devido à sua robustez e integração com bibliotecas de segurança, conforme discutido na Seção 2.3.2.

% =======================
% SEÇÃO 3.4 — ELABORATION
% =======================

\section{Fase de Elaboração (\textit{Elaboration})}

% Antes do texto que já está, inserir um parágrafo explicando que esta fase valida a arquitetura por meio de protótipos parciais (RUP exige).
% Algo como: “Protótipos de comunicação sensor–Arduino–Raspberry foram testados para verificar viabilidade.”

Nesta etapa foram definidos os artefatos estruturais do sistema, incluindo a modelagem dos casos de uso, a arquitetura de comunicação entre os dispositivos físicos e a especificação dos componentes embarcados que compõem o protótipo. Assim, esta fase estabelece o vínculo entre os requisitos levantados na Concepção e a implementação realizada na fase de Construção, garantindo que o sistema seja desenvolvido com base em uma arquitetura validada e documentada.

% A modelagem UML poderia incluir também um diagrama de classes ou sequência, caso haja tempo.

\subsection*{Modelagem de Caso de Uso}

O Diagrama de Caso de Uso, elaborado segundo a UML, fornece uma visão geral das interações entre os atores e as funcionalidades principais do sistema. Esse diagrama permite compreender como o usuário acessa as informações coletadas, como interage com o sistema e como os dispositivos físicos se integram às operações lógicas implementadas.

\begin{figure}[H]
    \centering
    \caption{Diagrama de Caso de Uso do Sistema}
    \label{fig:usecase}
    \includegraphics[width=1.0\textwidth]{imagens/meuDiagramaTcc.png}
    \caption*{Fonte: Autor.}
\end{figure}

\subsection*{Arquitetura Geral do Sistema}

O sistema foi concebido em uma arquitetura distribuída composta por sensores, um microcontrolador (Arduino), um microcomputador (Raspberry Pi), o \textit{back-end} desenvolvido em Spring Boot e a interface web criada com React. O fluxo principal consiste em:

1. Coleta dos dados pelos sensores conectados ao Arduino;
2. Comunicação entre Arduino e Raspberry Pi para envio das leituras;
3. Envio periódico das informações ao servidor por meio de requisições HTTP;
4. Armazenamento dos dados no banco PostgreSQL;
5. Apresentação dos parâmetros ao usuário via interface web.

Essa arquitetura permite escalabilidade e desacoplamento entre as camadas, em conformidade com os princípios discutidos no \autoref{cap:fundamentacao}. Contudo, alguns problemas podem ser encontrados nessa arquitetura, como a dependência de multiplos dipositivos físicos, que, qualquer falaha pode fazer com que o sistema pare de funcionar. Possiveis falhas nas requisições HTTP que já foram encontradas nas dependencias do IFG, podem interromper completamente a comunicação da aplicação no geral.

% Adicionar aqui uma análise crítica dos riscos identificados na arquitetura:
% - dependência de múltiplos dispositivos físicos
% - possíveis falhas de comunicação HTTP
% - necessidade de reconexão automática
% Isso demonstra maturidade metodológica.

\subsection*{Componentes Utilizados no Sistema}

A seguir apresentam-se os componentes físicos selecionados para o desenvolvimento do protótipo, incluindo sensores, atuadores e microcontroladores. A apresentação destes elementos nesta fase é coerente com o RUP, uma vez que a Elaboração contempla a definição da arquitetura física e lógica do sistema.

% -------------------------------------------------
% SENSOR DE TEMPERATURA
% -------------------------------------------------

\subsubsection*{Sensor de Temperatura}

\begin{figure}[H]
    \centering
    \caption{Sensor de Temperatura MF58 (NTC 10K)}
    \label{fig:sensortemp}
    \includegraphics[width=0.80\textwidth]{imagens/sensorTemperatura.png}
    \caption*{Fonte: \cite{siteComprei}.}
\end{figure}

O sensor selecionado para a medição da temperatura da água é o modelo MF58 (NTC 10K), um termistor cujo coeficiente de resistência decresce conforme a temperatura aumenta. A leitura é realizada por uma porta analógica do Arduino por meio de um divisor de tensão, permitindo a conversão da resistência em valores de temperatura.

% -------------------------------------------------
% SENSOR DE NÍVEL
% -------------------------------------------------

\subsubsection*{Sensor de Nível}

\begin{figure}[H]
    \centering
    \caption{Sensor de Nível LC26M-40}
    \label{fig:sensorlevel}
    \includegraphics[width=0.60\textwidth]{imagens/sensorNive.png}
    \caption*{Fonte: \cite{siteComprei2}.}
\end{figure}

O sensor de nível utilizado é o modelo LC26M-40, fabricado em Polipropileno (PP). Seu funcionamento baseia-se em um interruptor magnético interno (\textit{Reed Switch}), que altera seu estado conforme o flutuador se move com a variação do nível da água. O componente fornece um sinal digital tipo SPST, permitindo a identificação de nível crítico no reservatório.

% -------------------------------------------------
% SENSOR DE PH
% -------------------------------------------------

\subsubsection*{Sensor de pH}

O sensor de pH empregado no sistema realiza a medição da acidez da água da piscina. Os valores capturados são processados inicialmente no Arduino e enviados ao servidor para análise dos parâmetros e posterior recomendação de ajuste químico. A imagem será adicionada posteriormente, conforme previsto pelo aluno.

% -------------------------------------------------
% BOMBAS SUBMERSAS
% -------------------------------------------------

\subsubsection*{Bombas Submersas}

\begin{figure}[H]
    \centering
    \caption{Bomba Submersa JT100}
    \label{fig:bombasub}
    \includegraphics[width=0.60\textwidth]{imagens/bombaSubmersa.png}
    \caption*{Fonte: \cite{siteComprei}.}
\end{figure}

Foram empregadas bombas submersas de 3 a 5V, modelo JT100, responsáveis pelo enchimento, filtragem e acionamento da cascata. O equipamento apresenta vazão de 1000 a 1500 ml/min e altura máxima de elevação de 1 metro. Suas dimensões reduzidas e facilidade de integração justificam sua escolha para este protótipo.

% -------------------------------------------------
% ARDUINO
% -------------------------------------------------

\subsubsection*{Arduino}

\begin{figure}[H]
    \centering
    \caption{Placa Arduino Uno R3}
    \label{fig:arduino}
    \includegraphics[width=0.60\textwidth]{imagens/arduino.png}
    \caption*{Fonte: \cite{siteComprei4}.}
\end{figure}

O Arduino Uno R3 foi selecionado como microcontrolador responsável pela leitura direta dos sensores e pelo acionamento dos atuadores. Sua ampla compatibilidade com bibliotecas abertas e a quantidade adequada de pinos digitais e analógicos possibilitam atender aos requisitos levantados na Concepção.

% -------------------------------------------------
% RASPBERRY
% -------------------------------------------------

\subsubsection*{\textit{Raspberry Pi}}

\begin{figure}[H]
    \centering
    \caption{\textit{Raspberry Pi 3 Model B}}
    \label{fig:raspberry}
    \includegraphics[width=0.60\textwidth]{imagens/raspBerryQeuUso.png}
    \caption*{Fonte: \cite{siteComprei3}.}
\end{figure}

O \textit{Raspberry Pi 3 Model B} foi definido como o dispositivo intermediário entre o Arduino e o servidor. Seu processador quad-core, 1GB de RAM e compatibilidade com Linux permitem a execução de rotinas contínuas de envio de dados, comunicação co

% Dereck incluir na Elaboration uma tabela resumo com:
% - componente
% - função
% - tensão
% - protocolo de comunicação
% Isso melhora a organização e facilita leitura.


% =======================
% SEÇÃO 3.5 — CONSTRUCTION
% =======================

\section{Fase de Construção (\textit{Construction})}

% Antes da descrição, inserir uma frase explicando que esta fase implementou incrementos sucessivos conforme o RUP recomenda.
% Ex.: “A implementação ocorreu em ciclos, priorizando primeiro sensores e comunicação básica.”     (FEITO)

Em conformidade com a metodologia RUP, a fase de Construção foi executada por meio de ciclos iterativos e incrementais. O desenvolvimento iniciou-se pela camada física, com a implementação e validação individual dos sensores e atuadores no microcontrolador. Após garantir a estabilidade da leitura dos dados, iniciou-se a codificação da camada lógica, abrangendo o back-end (Spring Boot), o banco de dados e o front-end (React). A etapa final consistiu na integração completa entre o hardware e o software, validando o fluxo de transmissão das informações desde a coleta no ambiente físico até a visualização na interface web.

O desenvolvimento do código foi conduzido em duas camadas: a camada embarcada, responsável pela leitura e envio dos dados; e a camada de aplicação, que recebeu, armazenou e exibiu as informações aos usuários.
O desenvolvimento do código foi conduzido em duas camadas: a camada embarcada, responsável pela leitura e envio dos dados; e a camada de aplicação, que recebeu, armazenou e exibiu as informações aos usuários.

Na camada embarcada, o Arduino foi programado via IDE própria para realizar a leitura dos sensores analógicos e digitais. A Figura \ref{fig:cod_arduino} demonstra a função de coleta dos parâmetros da água e o acionamento condicional dos atuadores.

\begin{figure}[H]
    \centering
    \caption{Trecho de código do Arduino: Leitura de sensores e controle}
    \label{fig:cod_arduino}
    \includegraphics[width=0.9\textwidth]{imagens/arduino_code.jpeg} 
    % Ou use o ambiente lstlisting se for texto
    \caption*{Fonte: Autoria própria.}
\end{figure}

Em seguida, o Raspberry Pi atua como \textit{gateway}, utilizando scripts em Python para receber os dados via serial e encaminhá-los à nuvem. A Figura \ref{fig:cod_raspberry} ilustra a requisição HTTP POST realizada para enviar as leituras ao servidor.

\begin{figure}[H]
    \centering
    \caption{Script Python no Raspberry Pi: Envio de dados via HTTP}
    \label{fig:cod_raspberry}
    \includegraphics[width=0.9\textwidth]{imagens/bombaSubmersa.png}
    \caption*{Fonte: Autoria própria.}
\end{figure}

Na camada de aplicação, o \textit{back-end} desenvolvido em Spring Boot recebe essas requisições, persiste os dados no banco PostgreSQL e gerencia a lógica de negócios. A Figura \ref{fig:cod_backend} e a \ref{fig:cod_backend2} apresenta o \textit{Controller} responsável por receber os dados do sensor e o método para processar o comando de acionamento vindo da interface.

\begin{figure}[H]
    \centering
    \caption{Controller Spring Boot: Recepção de dados e endpoints de controle}
    \label{fig:cod_backend}
    \includegraphics[width=0.9\textwidth]{imagens/back_end_code.jpeg}
    \caption*{Fonte: Autoria própria.}
\end{figure}

Por fim, o \textit{front-end} em React consome essa API para consolidar a interface de visualização. A Figura \ref{fig:cod_frontend} exibe a função de resgate de dados (\textit{fetch}) para atualização dos gráficos e o componente de \textit{toggle} utilizado para enviar comandos manuais ao sistema.

\begin{figure}[H]
    \centering
    \caption{Componente React: Consumo de API e controle de estado}
    \label{fig:cod_frontend2}
    \includegraphics[width=0.9\textwidth]{imagens/frontEnd_resgatarBack.jpeg}
    \caption*{Fonte: Autoria própria.}
\end{figure}

\begin{figure}[H]
    \centering
    \caption{Componente React: Consumo de API e controle de estado}
    \label{fig:cod_frontend}
    \includegraphics[width=0.9\textwidth]{imagens/frontEnd_enviarBack.jpeg}
    \caption*{Fonte: Autoria própria.}
\end{figure}

% É necessário incluir trechos de código comentados (curtos), conforme exigência de TCC de software.
% Indicar onde: logo após o primeiro parágrafo da Construction.     (FEITO)

O Arduino, programado via IDE própria, capturou os parâmetros da água e acionou os atuadores quando necessário. O Raspberry Pi, utilizando scripts em Python, recebeu os dados do microcontrolador e os encaminhou ao servidor. O \textit{back-end}, desenvolvido em Spring Boot, estruturou a API responsável pela comunicação, enquanto o \textit{front-end} em React consolidou a interface de visualização.

% =======================
% SEÇÃO 3.6 — TRANSITION
% =======================

\section{Fase de Transição (\textit{Transition})}

Nesta fase, o sistema passou por testes práticos para validação do seu desempenho. Foram aplicados testes unitários nos sensores, incluindo calibração do NTC, verificação da estabilidade do sensor de nível e simulações de funcionamento crítico das bombas para evitar condições de \textit{dry-run}. Testes de integração verificaram o fluxo completo de dados, desde a leitura até a exibição na interface.

% Adicionar tabela com:
% - Teste realizado

Também foram realizados testes de responsividade da interface e de comunicação entre o servidor e o dispositivo embarcado. Os ajustes finais envolveram correções de algoritmos de conversão, ajustes de temporização e adequações na exibição gráfica dos dados.
% Inserir ao final desta seção uma reflexão crítica sobre limitações identificadas nos testes e possíveis trabalhos futuros derivados.