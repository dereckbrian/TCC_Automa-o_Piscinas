\chapter{Desenvolvimento}

\section{Tipo de Pesquisa e Etapas de Construção}

A pesquisa caracteriza-se como aplicada, de abordagem mista e de natureza exploratória e experimental. Inicialmente, foi realizado um estudo teórico sobre automação residencial, sensores, atuadores e controladores associados à Internet das Coisas (IoT), fundamentado nos autores apresentados no \autoref{cap:fundamentacao}. Essa etapa possibilitou a compreensão dos processos físico-químicos envolvidos no tratamento da água, das normas sanitárias aplicáveis e dos requisitos técnicos necessários para a integração entre hardware, software e dispositivos embarcados.

O levantamento bibliográfico incluiu artigos científicos, manuais técnicos e normas da Associação Brasileira de Normas Técnicas (ABNT), assegurando base conceitual e técnica suficiente para orientar as decisões posteriores de arquitetura, modelagem e implementação do sistema. Os critérios adotados para a seleção das fontes contemplaram a atualidade das informações, priorizando publicações dos últimos dez anos para temas relacionados à tecnologia, automação residencial e Internet das Coisas (IoT); a relevância técnica, com a utilização de manuais de fabricantes e guias especializados para fundamentar os processos físico-químicos de tratamento da água; e a robustez teórica, com a seleção de autores consolidados e trabalhos acadêmicos reconhecidos nas áreas de Engenharia de Software e arquitetura de sistemas.

Essa etapa inicial permitiu mapear os requisitos técnicos necessários à integração entre hardware, software e dispositivos embarcados, fornecendo subsídios consistentes para orientar as decisões de projeto adotadas ao longo do desenvolvimento do sistema.

\section{Processo de Desenvolvimento de Software}

Neste projeto, adotou-se o \textit{Rational Unified Process} (RUP) como metodologia de desenvolvimento, em razão de sua estrutura iterativa e incremental, do foco na mitigação de riscos e da ênfase na modelagem e na documentação do software. Conforme apresentado na fundamentação teórica, o RUP organiza o processo de engenharia de software em quatro fases principais: Concepção, Elaboração, Construção e Transição. Cada fase possui objetivos específicos que orientam a evolução do sistema, assegurando a rastreabilidade entre requisitos, arquitetura e implementação.

Considerando que o sistema desenvolvido envolve automação e dispositivos IoT, o ciclo de vida do desenvolvimento de hardware foi adaptado às fases do RUP. Nesse contexto, a definição e a seleção dos componentes eletrônicos ocorreram durante a fase de Concepção, enquanto a montagem física e a calibração dos sensores foram realizadas de forma integrada à fase de Construção, em paralelo à implementação do software.

A adoção dessa metodologia estabelece um fluxo contínuo de desenvolvimento, no qual cada artefato produzido em uma fase serve como base para a validação da fase subsequente. Assim, os requisitos levantados na fase de Concepção subsidiam a modelagem arquitetural realizada na fase de Elaboração, cujos diagramas orientam a implementação na fase de Construção. Por fim, a conformidade do sistema desenvolvido é verificada durante a fase de Transição, por meio de testes funcionais e ajustes finais.

As subseções seguintes descrevem detalhadamente cada uma dessas fases, destacando as atividades executadas e sua relação com os artefatos produzidos ao longo do processo.

\section{Fase de Concepção (\textit{Inception})}

Na fase de Concepção foram definidos o problema de pesquisa, o escopo inicial do projeto e os requisitos fundamentais do sistema. O problema identificado refere-se às dificuldades enfrentadas pelos usuários no processo manual de manutenção de piscinas, decorrentes da necessidade de medições frequentes, cálculos físico-químicos, além do risco de desperdício de produtos ocasionado pela aplicação imprecisa das dosagens recomendadas.

Com o objetivo de mitigar essas limitações, o sistema foi concebido para automatizar a leitura contínua dos principais parâmetros físico-químicos da água, reduzir a subjetividade na avaliação da qualidade, atuar de forma autônoma no sistema de filtragem com base na turbidez e disponibilizar interfaces remotas para monitoramento e acompanhamento do processo de manutenção.

O levantamento de requisitos resultou na definição dos requisitos funcionais (RF) e não funcionais (RNF), apresentados nas Tabelas \ref{tab:req_funcionais} e \ref{tab:req_nao_funcionais}, respectivamente.

\begin{table}[H]
    \centering
    \caption{Requisitos Funcionais do Sistema de Automação de Piscinas}
    \label{tab:req_funcionais}
    \begin{tabularx}{\textwidth}{l X}
    \toprule
    \textbf{Código} & \textbf{Descrição} \\
    \midrule
    \textbf{RF01} & O sistema deve monitorar automaticamente os níveis de pH, turbidez, temperatura e nível da água. \\
    \addlinespace
    \textbf{RF02} & O sistema deve acionar automaticamente a bomba de filtragem e o aquecedor conforme os parâmetros definidos ou coletados pelos sensores. \\
    \addlinespace
    \textbf{RF03} & O sistema deve disponibilizar uma interface web para visualização dos parâmetros monitorados. \\
    \addlinespace
    \textbf{RF04} & O sistema deve permitir o cadastro e o armazenamento dos dados coletados no banco de dados. \\
    \addlinespace
    \textbf{RF05} & O sistema deve permitir o cadastro de piscinas vinculadas a usuários. \\
    \addlinespace
    \textbf{RF06} & O sistema deve emitir alertas quando algum parâmetro ultrapassar os limites estabelecidos. \\
    \addlinespace
    \textbf{RF07} & O sistema deve gerar gráficos com base nos dados históricos dos parâmetros monitorados. \\
    \bottomrule
    \end{tabularx}
    \caption*{Fonte: Autoria própria (2025).}
\end{table}

Para a validação dos requisitos definidos, foram estabelecidos critérios quantitativos de aceitação, considerando o desempenho esperado para um protótipo IoT. A precisão dos sensores (RF01) foi definida com margem de erro inferior a $\pm$5\% em relação a medições de referência. Quanto ao desempenho temporal, estabeleceu-se que o tempo de latência total, compreendido entre a aquisição do dado físico pelo microcontrolador e sua visualização na interface web, não deve exceder cinco segundos, caracterizando uma monitoração em tempo quase real. No que se refere à comunicação (RNF03), o sistema é considerado estável quando as requisições HTTP apresentam taxa de sucesso superior a 95\% em operação contínua, com tempo de resposta do servidor inferior a quatro segundos por requisição. O requisito de automação (RF02) é considerado atendido quando o acionamento dos atuadores ocorre em até dois segundos após a detecção de uma condição crítica previamente parametrizada.

\begin{table}[H]
    \centering
    \caption{Requisitos Não Funcionais do Sistema de Automação de Piscinas}
    \label{tab:req_nao_funcionais}
    \begin{tabularx}{\textwidth}{l X}
    \toprule
    \textbf{Código} & \textbf{Descrição} \\
    \midrule
    \textbf{RNF01} & O sistema deve utilizar o banco de dados PostgreSQL para armazenamento das informações. \\
    \addlinespace
    \textbf{RNF02} & A interface web deve ser responsiva e acessível em dispositivos móveis e desktops. \\
    \addlinespace
    \textbf{RNF03} & A comunicação entre o microcontrolador e o servidor deve ocorrer de forma segura, utilizando os protocolos HTTP e HTTPS. \\
    \addlinespace
    \textbf{RNF04} & O sistema deve ser desenvolvido utilizando o framework Spring Boot no back-end e React no front-end. \\
    \bottomrule
    \end{tabularx}
    \caption*{Fonte: Autoria própria (2025).}
\end{table}

Para atender ao escopo definido, adotou-se uma arquitetura distribuída de hardware e software. Na camada física, selecionou-se o Arduino Uno para a leitura dos sensores e o acionamento dos atuadores, enquanto o Raspberry Pi foi designado para a comunicação entre o microcontrolador, o servidor e a aplicação web. Na camada de software, definiu-se o uso do framework Spring Boot no back-end, em virtude de sua robustez na implementação de APIs REST, React para o desenvolvimento da interface web responsiva e PostgreSQL para a persistência e o gerenciamento dos dados coletados.
\section{Fase de Elaboração (\textit{Elaboration})}

Com o objetivo de mitigar riscos técnicos e validar as principais decisões arquiteturais do sistema, foram desenvolvidos protótipos funcionais parciais, conforme recomendado pelo Rational Unified Process (RUP). Nessa etapa, realizaram-se testes preliminares de integração entre os sensores, o microcontrolador Arduino e o Raspberry Pi, com foco na verificação da estabilidade da comunicação serial, da latência no envio de dados e da viabilidade da arquitetura proposta. Esses experimentos permitiram confirmar que a infraestrutura de hardware selecionada atende aos requisitos de desempenho estabelecidos na fase de Concepção.

Nesta fase também foram definidos os principais artefatos estruturais do sistema, incluindo a modelagem dos casos de uso, a arquitetura de comunicação entre os dispositivos físicos e a especificação dos componentes embarcados que compõem o protótipo. Dessa forma, a fase de Elaboração estabelece a ligação entre os requisitos identificados na Concepção e a implementação conduzida na fase de Construção, assegurando que o sistema seja desenvolvido com base em uma arquitetura previamente validada e devidamente documentada.

\subsection*{Modelagem de Caso de Uso}

A modelagem de casos de uso, elaborada segundo a Linguagem de Modelagem Unificada (UML), fornece uma visão geral das interações entre os atores e as funcionalidades principais do sistema. O diagrama permite compreender como o usuário acessa as informações coletadas, como interage com o sistema por meio da interface web e como os dispositivos físicos se integram às operações lógicas implementadas no back-end.

\begin{figure}[H]
    \centering
    \caption{Diagrama de Caso de Uso do Sistema}
    \label{fig:usecase}
    \includegraphics[width=\textwidth]{imagens/meuDiagramaTcc.png}
    \caption*{Fonte: Autoria própria (2025).}
\end{figure}

\subsection*{Arquitetura Geral do Sistema}

O sistema foi concebido a partir de uma arquitetura distribuída, composta por sensores, um microcontrolador Arduino, um microcomputador Raspberry Pi, um back-end desenvolvido com o framework Spring Boot e uma interface web implementada em React. O fluxo principal de funcionamento do sistema ocorre conforme as seguintes etapas:

\begin{enumerate}
    \item Coleta dos dados pelos sensores conectados ao Arduino;
    \item Transmissão das leituras do Arduino para o Raspberry Pi;
    \item Envio periódico das informações ao servidor por meio de requisições HTTP;
    \item Armazenamento dos dados no banco de dados PostgreSQL;
    \item Apresentação dos parâmetros ao usuário por meio da interface web.
\end{enumerate}

Essa arquitetura favorece a escalabilidade e o desacoplamento entre as camadas do sistema, em conformidade com os princípios discutidos no \autoref{cap:fundamentacao}. Entretanto, a distribuição dos componentes físicos introduz riscos operacionais relevantes, como a dependência da integridade funcional de múltiplos dispositivos. A falha de um único nó, seja um sensor ou um controlador, pode comprometer temporariamente o fluxo de dados.

Além disso, a comunicação baseada em protocolos HTTP está sujeita a latências e instabilidades de rede, especialmente em infraestruturas domésticas, o que exige a implementação de mecanismos de tratamento de exceções, tentativas de reconexão automática e tolerância a falhas. Tais estratégias são fundamentais para garantir que o sistema seja capaz de recuperar sua operabilidade sem a necessidade de intervenção humana após falhas momentâneas de conectividade.

\subsection*{Componentes Utilizados no Sistema}

A seguir, são apresentados os principais componentes físicos selecionados para o desenvolvimento do protótipo, incluindo sensores, atuadores e dispositivos de controle. A definição desses elementos nesta fase está alinhada ao RUP, uma vez que a Elaboração contempla a consolidação da arquitetura física e lógica do sistema.

\subsubsection*{Sensor de Temperatura}

\begin{figure}[H]
    \centering
    \caption{Sensor de Temperatura MF58 (NTC 10K)}
    \label{fig:sensortemp}
    \includegraphics[width=0.80\textwidth]{imagens/sensorTemperatura.png}
    \caption*{Fonte: \cite{siteComprei}.}
\end{figure}

O sensor selecionado para a medição da temperatura da água foi o modelo MF58 (NTC 10K), um termistor cujo valor de resistência elétrica diminui à medida que a temperatura aumenta. A leitura é realizada por meio de uma entrada analógica do Arduino, utilizando um divisor de tensão, o que possibilita a conversão da resistência elétrica em valores de temperatura, posteriormente processados pelo sistema.

\subsubsection*{Sensor de Nível}

\begin{figure}[H]
    \centering
    \caption{Sensor de Nível LC26M-40}
    \label{fig:sensorlevel}
    \includegraphics[width=0.60\textwidth]{imagens/sensorNive.png}
    \caption*{Fonte: \cite{siteComprei2}.}
\end{figure}

O sensor de nível empregado no sistema é o modelo LC26M-40, fabricado em polipropileno (PP). Seu funcionamento baseia-se em um interruptor magnético interno (\textit{reed switch}), cujo estado é alterado conforme o deslocamento do flutuador provocado pela variação do nível da água. O dispositivo fornece um sinal digital do tipo SPST, permitindo a identificação de níveis críticos no reservatório.

\subsubsection*{Sensor de pH}

\begin{figure}[H]
    \centering
    \caption{Sensor de pH}
    \label{fig:sensorph}
    \includegraphics[width=0.60\textwidth]{imagens/sensorpH.png}
    \caption*{Fonte: \cite{siteCompreiPh}.}
\end{figure}

O sensor de pH utilizado no sistema é responsável pela medição do nível de acidez da água da piscina. Os valores capturados são inicialmente processados pelo Arduino e, em seguida, enviados ao servidor para análise dos parâmetros e suporte à tomada de decisão relacionada ao ajuste químico da água.

\subsubsection*{Sensor de Turbidez}

\begin{figure}[H]
    \centering
    \caption{Sensor de Turbidez ST100}
    \label{fig:sensorturbidez}
    \includegraphics[width=0.60\textwidth]{imagens/sensorTurbidez.png}
    \caption*{Fonte: \cite{siteCompreiTurbidez}.}
\end{figure}

O sensor de turbidez selecionado foi o modelo ST100, responsável por identificar a presença de partículas em suspensão na água. Os valores analógicos obtidos são processados pelo Arduino e enviados ao servidor para análise. Com base nesses dados, o sistema pode recomendar ou acionar automaticamente o processo de filtragem ou a aplicação de agentes decantadores, conforme os limites parametrizados.

\subsubsection*{Bombas Submersas}

\begin{figure}[H]
    \centering
    \caption{Bomba Submersa JT100}
    \label{fig:bombasub}
    \includegraphics[width=0.60\textwidth]{imagens/bombaSubmersa.png}
    \caption*{Fonte: \cite{siteComprei}.}
\end{figure}

Foram utilizadas bombas submersas de 3 a 5\,V, modelo JT100, responsáveis pelo enchimento, filtragem e acionamento da cascata do sistema. O equipamento apresenta vazão entre 1000 e 1500\,ml/min e altura máxima de elevação de aproximadamente 1\,m. Suas dimensões compactas, baixo consumo energético e facilidade de integração justificam sua adoção no protótipo desenvolvido.
\subsubsection*{Arduino}

\begin{figure}[H]
    \centering
    \caption{Placa Arduino Uno R3}
    \label{fig:arduino}
    \includegraphics[width=0.60\textwidth]{imagens/arduino.png}
    \caption*{Fonte: \cite{siteComprei4}.}
\end{figure}

O Arduino Uno R3 foi selecionado como o microcontrolador responsável pela leitura direta dos sensores e pelo acionamento dos atuadores do sistema. Sua ampla compatibilidade com bibliotecas de código aberto, aliada à quantidade adequada de pinos digitais e analógicos, permite atender aos requisitos funcionais definidos na fase de Concepção, especialmente no que se refere à aquisição de dados em tempo real e ao controle dos dispositivos físicos.

\subsubsection*{\textit{Raspberry Pi}}

\begin{figure}[H]
    \centering
    \caption{\textit{Raspberry Pi 3 Model B}}
    \label{fig:raspberry}
    \includegraphics[width=\textwidth]{imagens/raspBerryQeuUso.png}
    \caption*{Fonte: \cite{siteComprei3}.}
\end{figure}

O \textit{Raspberry Pi 3 Model B} foi definido como o dispositivo intermediário entre o Arduino e o servidor de aplicação. Seu processador quad-core, a memória RAM de 1\,GB e a compatibilidade com sistemas operacionais baseados em Linux possibilitam a execução contínua de rotinas de comunicação, processamento intermediário dos dados e envio das informações ao servidor por meio de requisições HTTP, desempenhando o papel de \textit{gateway} de comunicação do sistema.

\begin{table}[H]
    \centering
    \caption{Resumo das Especificações Técnicas dos Componentes de Hardware}
    \label{tab:resumo_hardware}
    \begin{tabularx}{\textwidth}{l >{\raggedright\arraybackslash}X c >{\raggedright\arraybackslash}X}
    \toprule
    \textbf{Componente} & \textbf{Função Principal} & \textbf{Tensão} & \textbf{Comunicação / Sinal} \\
    \midrule
    Raspberry Pi 3 B & Gateway de comunicação e envio de dados ao servidor & 5\,V & Serial (USB) / Wi-Fi (HTTP) \\
    \addlinespace
    Arduino Uno R3 & Leitura de sensores e controle de atuadores & 5\,V / 9\,V & Serial / I/O digital e analógico \\
    \addlinespace
    Sensor de Temperatura (NTC) & Monitoramento térmico da água & 5\,V & Analógico (divisor de tensão) \\
    \addlinespace
    Sensor de Nível & Detecção de nível crítico do reservatório & 5\,V & Digital (On/Off) \\
    \addlinespace
    Sensor de pH & Medição da acidez e alcalinidade da água & 5\,V & Analógico \\
    \addlinespace
    Sensor de Turbidez & Avaliação da transparência da água & 5\,V & Analógico \\
    \addlinespace
    Bomba Submersa & Circulação e filtragem da água & 3--6\,V & Acionamento via relé (sinal digital) \\
    \bottomrule
    \end{tabularx}
    \caption*{Fonte: Autoria própria (2025).}
\end{table}

\section{Fase de Construção (\textit{Construction})}

Em conformidade com a metodologia RUP, a fase de Construção foi conduzida por meio de ciclos iterativos e incrementais, nos quais funcionalidades do sistema foram implementadas e validadas progressivamente. O desenvolvimento iniciou-se pela camada física, com a implementação e a validação individual dos sensores e atuadores conectados ao microcontrolador. Após a estabilização da aquisição dos dados, procedeu-se à implementação da camada lógica, englobando o back-end, o banco de dados e o front-end. A etapa final concentrou-se na integração completa entre hardware e software, validando o fluxo de transmissão das informações desde a coleta no ambiente físico até a apresentação na interface web.

O desenvolvimento do sistema foi estruturado em duas camadas principais: a camada embarcada, responsável pela leitura, pré-processamento e envio dos dados coletados; e a camada de aplicação, encarregada de receber, armazenar e disponibilizar essas informações aos usuários.

Na camada embarcada, o Arduino foi programado por meio de sua IDE nativa para realizar a leitura dos sensores analógicos e digitais, bem como o acionamento condicional dos atuadores. Conforme apresentado no Apêndice \ref{apendice:codigos}, o Código \ref{fig:cod_arduino} ilustra a rotina de coleta dos parâmetros da água e a lógica empregada para o controle dos dispositivos físicos.

O Raspberry Pi desempenhou a função de \textit{gateway} de comunicação do sistema. Um script desenvolvido em Python foi responsável por estabelecer a comunicação serial com o microcontrolador, interpretar os dados recebidos e encaminhá-los ao servidor por meio de requisições HTTP do tipo POST. A lógica de implementação desse \textit{gateway}, incluindo os mecanismos de tratamento de falhas de comunicação e a serialização dos dados em formato JSON, encontra-se detalhada no Apêndice \ref{apendice:codigos}, Código \ref{lst:python_gateway}.

Na camada de aplicação, o back-end, implementado com o framework Spring Boot, disponibiliza os \textit{endpoints} necessários para a recepção e a persistência dos dados coletados. O \textit{controller} responsável por mapear as requisições, converter os objetos JSON e armazenar as leituras no banco de dados PostgreSQL está apresentado no Apêndice \ref{apendice:codigos}, Código \ref{lst:backend_controller}. Essa arquitetura centraliza a regra de negócios, assegurando a integridade, a consistência e a disponibilidade do histórico de monitoramento.

Por fim, a interface do usuário, desenvolvida em React, consome os dados fornecidos pela API para apresentar o estado atual da piscina em tempo quase real. A implementação da lógica de consumo da API e o gerenciamento de estado para visualização dos parâmetros e acionamento manual dos atuadores estão descritos no Apêndice \ref{apendice:codigos}, Código \ref{lst:frontend_fetch}.

\section{Fase de Transição (\textit{Transition})}

Na fase de Transição, o sistema desenvolvido foi submetido a testes práticos com o objetivo de validar seu desempenho, estabilidade e conformidade com os requisitos estabelecidos nas fases anteriores. Foram realizados testes unitários nos sensores, abrangendo a calibração do sensor NTC de temperatura, a verificação da estabilidade do sensor de nível e simulações de condições críticas de funcionamento das bombas, de modo a prevenir situações de \textit{dry-run}. Paralelamente, testes de integração avaliaram o fluxo completo dos dados, desde a aquisição no ambiente físico até a apresentação das informações na interface web.

\begin{table}[H]
    \centering
    \caption{Resumo dos Testes Realizados e Resultados Obtidos}
    \label{tab:testes_realizados}
    \begin{tabularx}{\textwidth}{ >{\raggedright\arraybackslash}p{4cm} >{\raggedright\arraybackslash}X >{\raggedright\arraybackslash}p{3cm} }
    \toprule
    \textbf{Teste Realizado} & \textbf{Objetivo do Teste} & \textbf{Resultado} \\
    \midrule
    Calibração do Sensor NTC & Verificar a precisão térmica por comparação com termômetro de referência & Aprovado \\
    \addlinespace
    Calibração do Sensor de pH & Comparar as leituras do sensor com estojos comerciais de análise da água & Aprovado \\
    \addlinespace
    Validação de Turbidez & Avaliar linearidade e sensibilidade por meio de diluição seriada (água límpida e saturada) & Aprovado \\
    \addlinespace
    Estabilidade do Sensor de Nível & Confirmar o acionamento correto da boia sem oscilações espúrias (\textit{debounce}) & Aprovado \\
    \addlinespace
    Proteção \textit{Dry-run} & Impedir o acionamento da bomba em condição de reservatório vazio & Aprovado \\
    \addlinespace
    Integração de Dados & Validar o fluxo completo Arduino $\rightarrow$ Raspberry Pi $\rightarrow$ Banco de Dados & Aprovado \\
    \addlinespace
    Latência da Interface & Medir o tempo entre a leitura do sensor e a atualização na interface web & Aprovado \\
    \bottomrule
    \end{tabularx}
    \caption*{Fonte: Autoria própria (2025).}
\end{table}

Adicionalmente, foram realizados testes de responsividade da interface web e de confiabilidade da comunicação entre o servidor e os dispositivos embarcados. Os ajustes finais envolveram a correção de algoritmos de conversão dos sensores, a adequação de temporizações de leitura e transmissão, bem como melhorias na visualização gráfica dos dados apresentados ao usuário.

Apesar dos resultados satisfatórios obtidos nos testes, foram identificadas limitações inerentes à prototipagem em escala reduzida. A principal restrição técnica observada refere-se à calibração fina dos sensores analógicos de turbidez e pH, os quais apresentaram sensibilidade a ruídos elétricos e variações ambientais, demandando tratamento adicional dos sinais por meio de filtragem e normalização em software. Tais limitações evidenciam que, embora o sistema atenda aos requisitos funcionais propostos, sua precisão pode ser impactada por fatores externos em cenários de uso prolongado.

Outro aspecto relevante diz respeito à dependência da infraestrutura de rede local. Falhas momentâneas de conectividade podem ocasionar atrasos ou lacunas temporárias no monitoramento em tempo real, ainda que não comprometam o armazenamento posterior dos dados. Esse comportamento reforça a necessidade de estratégias adicionais de tolerância a falhas, como armazenamento local temporário e mecanismos de retransmissão automática.

Como perspectivas de trabalhos futuros, recomenda-se a validação do sistema em uma piscina de alvenaria em escala real, permitindo avaliar o desempenho dos sensores sob condições ambientais variáveis e uso contínuo. Sugere-se, ainda, a incorporação de um sensor de cloro livre (ORP), de modo a fechar o ciclo completo de automação química, bem como a implementação de algoritmos de aprendizado de máquina voltados à manutenção preditiva, com o objetivo de antecipar falhas em bombas e sensores a partir do histórico operacional.
